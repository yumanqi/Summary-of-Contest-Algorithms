# 10.并查集

并查集的经典应用有：判断连通性、最小生成树Kruskal算法、最近公共祖先（LCA）等。

并查集是Kruskal算法的绝配，如果不用并查集，Kruskal算法很难编码。

## 10.1 并查集的基本操作

用“帮派”的例子来说明并查集的应用场景。

- 一个城市中有n个人，他们分成不同的帮派；
- 给出一些人的关系，例如1号、2号是朋友，1号、3号也是朋友，那么他们都属于一个帮派；
- 请分析所有的朋友关系；
- 问：有多少帮派，每人属于哪个帮派？

n可能大于1百万。

这个问题如果用并查集实现，不仅代码很简单，而且计算复杂度几乎是O(1)的，效率极高。

用“帮派”为例子说明并查集的基本操作。

有三个基本操作：初始化、合并、查找。

**（1）初始化。**开始的时候，帮派的每个人是独立的，相互之间没有关系。把每个人抽象成一个点，每个点有独立的集，n个点就有n个集。

**（2）合并。**把2个点合并到一个集，就是把2个人所属的帮合并成一个帮。

**（3）查找某个点属于哪个集。**

**（4）统计有几个集。**

## 10.2 路径压缩

**路径压缩**是并查集的核心技术.

如果在递归返回的时候，顺便把这条路径上所有的点所属的集改成根结点（所有人都只有帮主一个上级，而不再有其他上级），那么下次再查这条路径上的点属于哪个集，就能在O(1)的时间内得到结果.

```c
int find(int x)
{
	if(x!=s[x])
	s[x] = find(s[x]);
	return s[x];
}
```

## 10.3判断亲戚关系

题目：https://www.luogu.com.cn/problem/P1551

```c
#include<bits/stdc++.h>
using namespace std;

int n,m,p;
int s[5001];
int find(int x)
{
	if(x!=s[x])
	s[x] = find(s[x]);
	return s[x];
}
void bcj(int x,int y)
{
	x = find(x);
	y = find(y);
	if(s[x]!=s[y])
	s[x] = s[y];
}


int main(){
	cin >> n >> m >> p;
	//并查集初始化
	for(int i=1;i<=n;i++)
	s[i] = i;
	for(int i=1;i<=m;i++)
	{
	    int x,y;
		cin >> x >> y;
		bcj(x,y);	
	} 
	//查询
	 for(int i=1;i<=p;i++)
	 {
	 	int x,y;
	 	cin >> x >> y;
	 	x = find(x);
	 	y = find(y);
	 	if(x==y)
	 	cout << "yes" ;
	 	else
	 	cout << "no" ;
	 }
	return 0;
} 
```

# 
