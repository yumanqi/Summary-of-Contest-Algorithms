# 11.前缀和和差分

## 11.1 前缀和

一个长度为n的数组a[1] ~ a[n]，前缀和sum[i]等于a[1] ~ a[i]的和：

sum[i] = a[1] + a[2] + ... + a[i] 

### n个整数，两两相乘再求和

* 两个for循环（计算量太大，超时）

* 前缀和

  S= (a1+a2 +...+an-1)×an

    +(a1+a2+...+an-2)×an-1

    +(a1+a2+...+an-3)×an-2

    +...

    +(a1+a2)×a3

    \+ a1×a2

  当题目的计算和区间计算有关，且需要做大量区间计算时，可以试试用前缀和优化计算。

  ```c
  #include<bits/stdc++.h>
  using namespace std;
  
  int a[1000000];
  int n;
  int sum[1000000]={0};//前缀和 
  long long s=0;
  int main(){
  	cin >> n;
  	for(int i=1;i<=n;i++)
  	{
  		cin >> a[i];
  		sum[i] = sum[i-1]+a[i];
  	}
  	for(int i=1;i<n;i++)
  	{
  		s+=sum[i]*a[i+1];
  	}
  	cout << s;
  	return 0;
  }
  ```

## 11.2 差分

把区间[L, R]内每个元素a[]加上v，只需要把对应的d[]做以下操作：

（1）把d[L]加上v：  d[L] += v

（2）把d[R+1]减去v：d[R+1] -= v

利用d[]，能精确地实现只修改区间内元素的目的，而不会修改区间外的a[]值。根据前缀和a[x] = d[1] + d[2] + ... + d[x]，有：

（1）1 ≤ x < L，前缀和a[x]不变；

（2）L ≤ x ≤ R，前缀和a[x]增加了v；

（3）R < x ≤ N，前缀和a[x]不变，因为被d[R+1]中减去的v抵消了。

每次操作只需要修改区间[L, R]的两个端点的d[]值，复杂度是O(1)的。

### 重新排序问题

给定一个数组A和一些查询Li, Ri，求数组中第Li至第Ri个元素之和。小蓝觉得这个问题很无聊，于是他想重新排列一下数组，使得最终每个查询结果的和尽可能地大。小蓝想知道相比原数组，所有查询结果的总和最多可以增加多少? 

#### 1.通过70%测试用例

根据m个查询，计算出每个位置被查询的次数，并给数组元素按大小排序。

查询次数最多的位置放元素最大的，剩下的同理。

#### 2.通过100%测试用例

创建差分数组d，存储次数；将差分数组元素加到每个位置被查询的次数上。

参考原文：https://mp.weixin.qq.com/s/Q-LgP2aUsRVbFtzMA4wc4g

# 
